



(Graph & Tree)
1263D

-- Using graph with strings and optimizing such that it uses only linear time.
-- Nice and simple question

1139C.cpp

-- Nice question using BFS, connected component of undirected graph and binary exponentiation

982C
-- Using DFS tree we can use to do traversal from top to bottom even for the algo which intutively reguires leaf to root traversal.
-- For trees we can find answer by finding answers from subtree using dfs and adding to the final answer

977E.cpp
-- for cyclic component in undirected component check each vertex has degree = 2

770c.cpp -- Topological Sorting and Cycle Detection(Important)

771A.cpp -- Clique 
1106D
1147A














(implementation question)
1169B 
-- standard question
-- question:
Toad Ivan has m pairs of integers, each integer is between 1 and n, inclusive. The pairs are (a1,b1),(a2,b2),…,(am,bm).
He asks you to check if there exist two integers x and y (1≤x<y≤n) such that in each given pair at least one integer is equal to x or y.


1296C.cpp
-- When using path from x1,y1 to xn,yn sometimes storing path in map is useful in reducing overall timecomplexity

1234C.cpp
-- When using geometry or pipes to form a path from source to destination, find the condition in which pipe flow will be broken

1264A.cpp

1287B.cpp
-- Nice question on implementation. Used map to reduce to timecomplexity

1340A.cpp
-- when we need to check given input can be formed using condition given in question. We need to find an unique property of answer generated by the condition and just check that property in given inputs.

1323B.cpp (count subrectangles)
-- Matrix question reduced to number theory question with preprocessing.














(Two Pointers)
224B.cpp
Assume largest possible answer set and moving both pointers such that  condition is satisfied.

1304C.cpp
When condition need to satisfy with multiple range, generate a range check it's intersection with first input, then check it, if verified then modify range.



(Number Theory)

1242A.cpp
Chinese remainder theoram is used
1195D1.cpp


(greedy algorithm)
1368B.cpp
-- given string s of length n find shortest string that contains atleast k string s subsequences.
-- logic when no two adjacent character are same. find a1,a2,... an s.t. t=a1*a2...*an
t>=k and t is smallest such number and all 
a[i] are as small as possible. 
-- implentation: start with all a[i] = 1 and increase each by one by one by 1 till we get required t 


1325c.cpp
-- label a tree edges with 0 to n-2 inclusive
s.t. mex(u,v) { denotes the smallest non-negative integer that isn't written on any edge on the unique simple path from node u to node v.} over all pairs of nodes is as small as possible

-- In this type of questions check what values are possible for mex() and what not.

-- 0 & 1 is not possible. mex() can be made 2 if atleast one vertex has degree >= 3 other wise mex() = n-1(for linear tree) 


1313C1.cpp
-- Used segment tree. {instead of minimum value, store index of minimum value}
-- then use recursive algorithm(it has n states)

1301B.cpp

1299A.cpp
-- maximise f(f(…f(f(a1,a2),a3),…an−1),an) 
where f(x,y)=(x|y)−y 
-- now in this type of question try to convert bitwise operator to binary operator as answer can be easily arrived with them using their associative and distributive property
-- here f(x,y) = x&(~y)

1296D.cpp

1278B.cpp
-- You are given two integers a and b. You can perform a sequence of operations: during the first operation you choose one of these numbers and increase it by 1; during the second operation you choose one of these numbers and increase it by 2, and so on. 
Find minimum no. of operations required to make them equal

-- Nice math question
d = a-b (assuming a>b) 
ans is some minimum k (assume d1 = k(k+1)/2)
 s.t 
d1>= d
and d1 and d has same parity
 
in such condition d + (d1-d)/2  to b 
and (d1-d)/2 to a

1256D.cpp

1253C.cpp
-- question using nice implementation technique to write short and efficient code. See code.
-- each day has m slots (as a Yui can eat only m sweet in one day). Maintain an array of size m and sort the array and start from index 0. See the code.


1250L


1249C.cpp
-- base 3 calculation and finding answer
-- Nice question. See code again.


1215C.cpp


1207C.cpp
-- Nice DP question. 
-- In this question we have dp[i][state]
-- i is length of pipeline and state accounts
	for possible variation in piplenine at particular length
-- we can work using 2 state :- 
	a) pillar length 1 
	b) pillar length 2
-- or we can work using 4 states:- 
	at particular segment pipeline structure
	a) length a, at height 1
	b) length a, at height 2
	c) length 2*a, left end at height 1 and right end at height 2
	d) length 2*a, left end at height 2 and right end at height 1
-- correspondingly we can arrive at dp transitions

-- Standard DP algorithm. Memorise it.


1203E.cpp

1201B.cpp
-- Nice mathematics question.
-- see code for explanantion

1178D.cpp
-- Core number theory concept: there exists atleast one prime number between n and 3*n/2

1186D.cpp